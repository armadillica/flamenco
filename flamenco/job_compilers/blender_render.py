import abc
import functools
import pathlib
import typing

import bson
from pillar import attrs_extra

from flamenco import current_flamenco, exceptions
from pillar.api.utils import random_etag, utcnow
from .abstract_compiler import AbstractJobCompiler
from . import commands, register_compiler

RNA_OVERRIDES_TASK_NAME = 'rna-overrides'
RNA_OVERRIDES_HEADER = """\
# RNA OVERRIDES
#
# This file contains overrides for RNA properties and was generated by
# Flamenco based on the job definition of this render job.
#
# This file should be placed next to the blend file that is going to be
# rendered and named the same (except '-overrides.py' instead of '.blend').
import bpy
"""

# Set of scene.render.image_settings.file_format values that produce
# files which FFmpeg is known not to handle as input.
FFMPEG_INCOMPATIBLE_IMAGE_FORMATS = {
    'EXR', 'MULTILAYER',  # Old CLI-style format indicators
    'OPEN_EXR', 'OPEN_EXR_MULTILAYER',  # DNA values for these formats.
}


@functools.lru_cache(maxsize=1)
def job_types() -> typing.Set[str]:
    """Return set of job type names that are Blender Render jobs.

    Cached for efficiency.
    """
    from . import compilers

    return {name for name, compiler in compilers.items()
            if issubclass(compiler, AbstractBlenderJobCompiler)}


def intermediate_path(job: dict, render_path: pathlib.PurePath) -> pathlib.PurePath:
    """Determine the intermediate render output path."""

    name = f'{render_path.name}__intermediate-{job["_created"]:%Y-%m-%d_%H%M%S}'
    return render_path.with_name(name)


def rna_overrides_command(job: dict) -> commands.CreatePythonFile:
    """Create a command that writes a Python file with RNA overrides.

    Assumes that the job has 'rna_overrides' and 'filepath' settings.
    """

    rna_overrides = job['settings'].get('rna_overrides')
    assert rna_overrides, f'Job {job["_id"]} has no "rna_overrides" setting'

    filepath = job['settings']['filepath']

    index = filepath.lower().rindex('.blend')
    override_filepath = filepath[:index] + '-overrides.py'

    file_contents = '\n'.join((RNA_OVERRIDES_HEADER, *rna_overrides, ''))
    cmd = commands.CreatePythonFile(
        filepath=override_filepath,
        contents=file_contents,
    )
    return cmd


class AbstractBlenderJobCompiler(AbstractJobCompiler, metaclass=abc.ABCMeta):
    """Blender Render job compiler with support for RNA Overrides."""
    _log = attrs_extra.log('%s.AbstractBlenderJobCompiler' % __name__)

    # noinspection PyMethodOverriding
    def validate_job_settings(self, job: dict, *, _must_have_filepath=False):
        super().validate_job_settings(job)

        # For compilation we really need to have the filepath setting.
        # Missing it is only valid when status='waiting-for-files'.
        if 'filepath' in job['settings']:
            filepath = job['settings']['filepath']
            if not isinstance(filepath, str):
                raise exceptions.JobSettingError(f'filepath should be a string, not {filepath!r}')
            if not filepath.lower().endswith('.blend'):
                raise exceptions.JobSettingError(
                    f'filepath should end in .blend, but is {filepath!r}')
        elif job['status'] != 'waiting-for-files' or _must_have_filepath:
            raise exceptions.JobSettingError("missing setting 'filepath'")

    def _make_rna_overrides_task(self,
                                 job: dict,
                                 parent_task_id: typing.Optional[bson.ObjectId] = None) \
            -> typing.Optional[bson.ObjectId]:
        """Create a task that writes a Python file with RNA overrides."""

        rna_overrides = job['settings'].get('rna_overrides')
        if not rna_overrides:
            return None

        parent_task_ids = [parent_task_id] if parent_task_id else None
        cmd = rna_overrides_command(job)
        task_id = self._create_task(job, [cmd], RNA_OVERRIDES_TASK_NAME, 'file-management',
                                    parents=parent_task_ids)
        return task_id

    @abc.abstractmethod
    def insert_rna_overrides_task(self, job: dict) -> bson.ObjectId:
        """Inject a new RNA Overrides task into an existing job.

        Implement in a subclass. Can use _insert_rna_overrides_task() to do
        the heavy lifting.

        Returns the new task ID.
        """

    def _insert_rna_overrides_task(self, job: dict,
                                   parent_task_selector: dict) -> bson.ObjectId:
        # Find the task that is supposed to be the parent of the new task.
        tasks_coll = current_flamenco.db('tasks')
        if parent_task_selector:
            parent_task = tasks_coll.find_one({'job': job['_id'], **parent_task_selector},
                                              projection={'_id': True})
            if not parent_task:
                raise ValueError('unable to find move-out-of-way task, cannot update this job')

            parents_kwargs = {'parents': [parent_task['_id']]}
        else:
            parents_kwargs = {}

        # Construct the new task.
        cmd = rna_overrides_command(job)
        task_id = self._create_task(job, [cmd], RNA_OVERRIDES_TASK_NAME,
                                    'file-management', priority=80,
                                    status='queued', **parents_kwargs)
        self._log.info('Inserted RNA Overrides task %s into job %s', task_id, job['_id'])

        # Update existing render tasks to have the new task as parent.
        new_etag = random_etag()
        now = utcnow()
        result = tasks_coll.update_many({
            'job': job['_id'],
            'task_type': 'blender-render',
            **parents_kwargs,
        }, {'$set': {
            '_etag': new_etag,
            '_updated': now,
            'parents': [task_id],
        }})
        self._log.debug('Updated %d task parent pointers to %s', result.modified_count, task_id)
        return task_id

    def update_rna_overrides_task(self, job: dict):
        """Update or create an RNA Overrides task of an existing job."""
        tasks_coll = current_flamenco.db('tasks')
        task = tasks_coll.find_one({'job': job['_id'], 'name': RNA_OVERRIDES_TASK_NAME},
                                   projection={'_id': True})
        if not task:
            self.insert_rna_overrides_task(job)
            return

        cmd = rna_overrides_command(job)
        new_etag = random_etag()
        now = utcnow()
        result = tasks_coll.update_one(task, {'$set': {
            '_etag': new_etag,
            '_updated': now,
            'status': 'queued',
            'commands': [cmd.to_dict()],
        }})

        self._log.info('Modified %d RNA override task (%s) of job %s',
                       result.modified_count, task['_id'], job['_id'])


@register_compiler('blender-render')
class BlenderRender(AbstractBlenderJobCompiler):
    """Basic Blender render job."""
    _log = attrs_extra.log('%s.BlenderRender' % __name__)

    REQUIRED_SETTINGS = ('render_output', 'frames', 'chunk_size')

    # noinspection PyMethodOverriding
    def validate_job_settings(self, job: dict, *, _must_have_filepath=False):
        super().validate_job_settings(job, _must_have_filepath=_must_have_filepath)

        if not isinstance(job, dict):
            raise TypeError('job should be a dict, not %s' % type(job))

        fps = job['settings'].get('fps')
        if fps is not None and not isinstance(fps, (int, float)):
            raise exceptions.JobSettingError(
                f'Job {job["_id"]} has non-numerical "fps" setting {fps!r}')

        rna_overrides = job['settings'].get('rna_overrides') or []
        if not all(isinstance(override, str) for override in rna_overrides):
            raise exceptions.JobSettingError(
                f'Job {job["_id"]} has non-string element in '
                f'"rna_overrides" setting {rna_overrides!r}')

    def _compile(self, job):
        self._log.info('Compiling job %s', job['_id'])
        self.validate_job_settings(job, _must_have_filepath=True)

        rna_overrides_task_id = self._make_rna_overrides_task(job)

        # The render path contains a filename pattern, most likely '######' or
        # something similar. This has to be removed, so that we end up with
        # the directory that will contain the frames.
        self.render_output = pathlib.PurePath(job['settings']['render_output'])
        self.final_dir = self.render_output.parent
        self.render_dir = intermediate_path(job, self.final_dir)

        render_tasks, parent_tasks = self._make_render_tasks(job, rna_overrides_task_id)
        create_video_task = self._make_create_video_task(job, parent_tasks)

        if create_video_task is None:
            final_parents = parent_tasks
        else:
            final_parents = [create_video_task]
        self._make_move_to_final_task(job, final_parents)

        task_count = len(render_tasks) + 1 + (create_video_task is not None)
        self._log.info('Created %i tasks for job %s', task_count, job['_id'])

    def _make_move_to_final_task(self, job,
                                 parent_task_ids: typing.List[bson.ObjectId]) -> bson.ObjectId:
        """Creates a MoveToFinal command to back up existing frames, and wraps it in a task.

        :returns: the ObjectId of the created task.
        """

        cmd = commands.MoveToFinal(
            src=str(self.render_dir),
            dest=str(self.final_dir),
        )

        task_id = self._create_task(job, [cmd], 'move-to-final', 'file-management',
                                    parents=parent_task_ids)
        return task_id

    def _make_create_video_task(self, job, parent_task_ids: typing.List[bson.ObjectId]) \
            -> typing.Optional[bson.ObjectId]:
        """Creates a CreateVideo command to render a video, and wraps it in a task.

        :returns: the ObjectId of the created task, or None if this task should not
            be created for this job.
        """
        from flamenco import utils

        if not isinstance(job, dict):
            raise TypeError('job should be a dict, not %s' % type(job))

        job_id: bson.ObjectId = job['_id']
        job_settings = job['settings']

        # Check whether we should create this task at all.
        images_or_video = job_settings.get('images_or_video', '-not set-')
        if images_or_video != 'images':
            self._log.debug('Not creating create-video task for job %s with images_or_video=%s',
                            job_id, images_or_video)
            return None

        frame_count = utils.frame_range_count(job_settings['frames'])
        if frame_count < 2:
            self._log.debug('Not creating create-video task for job %s with only %d frames',
                            job_id, frame_count)
            return None

        # Check whether we can use the render output to feed to FFmpeg.
        if job_settings['format'] in FFMPEG_INCOMPATIBLE_IMAGE_FORMATS:
            self._log.debug('Not creating create-video task for job %s with format=%s',
                            job_id, job_settings['format'])
            return None

        try:
            fps = job_settings['fps']
        except KeyError:
            self._log.debug('Not creating create-video task for job %s without fps setting', job_id)
            return None

        try:
            output_file_extension = job_settings['output_file_extension']
        except KeyError:
            self._log.debug('Not creating create-video task for job %s without '
                            'output_file_extension setting', job_id)
            return None

        # Check the Manager to see if the task type we need is supported at all.
        manager_id: bson.ObjectId = job.get('manager')
        if not manager_id:
            self._log.error('Job %s is not assigned to a manager; not creating create-video task',
                            job_id)
            return None
        manager = current_flamenco.db('managers').find_one(
            manager_id, projection={'worker_task_types': 1})
        if not manager:
            self._log.error('Job %s has non-existant manager %s; not creating create-video task',
                            job_id, manager_id)
            return None
        if 'worker_task_types' not in manager:
            self._log.info('Manager %s for job %s has no known worker task types; '
                           'not creating create-video task', job_id, manager_id)
            return None
        if 'video-encoding' not in manager['worker_task_types']:
            self._log.info('Manager %s for job %s does not support the video-encoding task type; '
                           'not creating create-video task', job_id, manager_id)
            return None

        blendfile = pathlib.Path(job_settings['filepath'])
        stem = blendfile.stem.replace('.flamenco', '')
        outfile = self.render_dir / f'{stem}-{job_settings["frames"]}.mkv'

        cmd = commands.CreateVideo(
            input_files=str(self.render_dir / f'*{output_file_extension}'),
            output_file=str(outfile),
            fps=fps,
        )

        task_id = self._create_task(job, [cmd], 'create-video', 'video-encoding',
                                    parents=parent_task_ids)
        return task_id

    def _make_render_tasks(self, job, parent_task_id: typing.Optional[bson.ObjectId]) \
            -> typing.Tuple[typing.List[bson.ObjectId], typing.List[bson.ObjectId]]:
        """Creates the render tasks for this job.

        :returns: two lists of task IDs: (all tasks, parent tasks for next command)
        """
        from flamenco.utils import iter_frame_range, frame_range_merge

        job_settings = job['settings']
        parent_task_ids = [parent_task_id] if parent_task_id else None

        task_ids = []
        for chunk_frames in iter_frame_range(job_settings['frames'], job_settings['chunk_size']):
            frame_range = frame_range_merge(chunk_frames)
            frame_range_bstyle = frame_range_merge(chunk_frames, blender_style=True)

            task_cmds = [
                commands.BlenderRender(
                    blender_cmd=job_settings.get('blender_cmd', '{blender}'),
                    filepath=job_settings['filepath'],
                    format=job_settings.get('format'),
                    render_output=str(self.render_dir / self.render_output.name),
                    frames=frame_range_bstyle)
            ]

            name = 'blender-render-%s' % frame_range
            task_ids.append(self._create_task(job, task_cmds, name, 'blender-render',
                                              parents=parent_task_ids))

        return task_ids, task_ids

    def insert_rna_overrides_task(self, job: dict) -> bson.ObjectId:
        """Inject a new RNA Overrides task into an existing job.

        Returns the new task ID.
        """
        return self._insert_rna_overrides_task(job, {})
